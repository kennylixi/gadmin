// ============================================================================
// This is auto-generated by gen tool only once. Fill this file as you wish.
// 文件管理Logic层
// @author kennylixi
// @date 2023-03-23 14:14:45
// ============================================================================

package service

import (
	"bytes"
	"context"
	"fmt"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/net/ghttp"
	"github.com/gogf/gf/v2/os/gfile"
	"github.com/gogf/gf/v2/text/gregex"
	"github.com/gogf/gf/v2/text/gstr"
	"github.com/gogf/gf/v2/util/gconv"
	"github.com/gogf/gf/v2/util/guid"
	"github.com/kennylixi/gadmin/internal/consts/config_consts"
	"github.com/kennylixi/gadmin/internal/consts/mime_type"
	commonService "github.com/kennylixi/gadmin/internal/modules/common/service"
	"github.com/kennylixi/gadmin/internal/modules/system/dao"
	systemModel "github.com/kennylixi/gadmin/internal/modules/system/model"
	"github.com/kennylixi/gadmin/internal/modules/system/model/do"
	"github.com/kennylixi/gadmin/internal/modules/system/model/entity"
	"github.com/kennylixi/gadmin/internal/modules/system/service"
	"github.com/kennylixi/go-filesys"
	"net/url"
	"os"
)

// File 文件管理管理服务
type sFile struct{}

func init() {
	service.RegisterFile(New())
}

func New() *sFile {
	return &sFile{}
}

// LoadDrivers 加载所有驱动
func (s *sFile) LoadDrivers(ctx context.Context) error {
	drivers, err := service.FileDriver().SelectList(ctx, &systemModel.FileDriverListInput{})
	if err != nil {
		return err
	}
	if drivers != nil && drivers.List != nil {
		var master *entity.FileDriver
		for _, driver := range drivers.List {
			if driver.Master {
				master = driver
			}
			// 添加本地静态目录
			if driver.Driver == filesys.TypeLocal {
				cfg := (*filesys.ConfigLocal)(nil)
				if err = driver.Config.Scan(&cfg); err != nil {
					return err
				}
				if cfg.IsDev == "1" {
					if !gfile.Exists(cfg.Path) {
						if err = gfile.Mkdir(cfg.Path); err != nil {
							return err
						}
						if err = gfile.Chmod(cfg.Path, os.FileMode(0776)); err != nil {
							return err
						}
					}
					g.Server().AddStaticPath("/public", cfg.Path)
				}
			}
		}
		return filesys.Init(ctx, master.Driver, master.Config.Interface())
	}
	return nil
}

// SetMasterDriver 初始化主驱动
// @param defaultDriver 默认驱动
func (s *sFile) SetMasterDriver(ctx context.Context, driverId ...int64) (err error) {
	var master *entity.FileDriver
	if len(driverId) == 0 {
		master, err = service.FileDriver().GetMasterDriver(ctx)
		if err != nil {
			return err
		}
	} else {
		master, err = service.FileDriver().SelectById(ctx, driverId[0])
		if err != nil {
			return err
		}
	}

	return filesys.Init(ctx, master.Driver, master.Config.Interface())
}

// SelectById 查询文件管理信息
func (s *sFile) SelectById(ctx context.Context, id int64) (sysFile *entity.File, err error) {
	err = dao.File.Ctx(ctx).Fields(&entity.File{}).Scan(&sysFile, dao.File.Columns().Id, id)
	if err != nil {
		return nil, err
	}
	if sysFile == nil {
		return nil, gerror.New("数据不存在")
	}

	return sysFile, nil
}

// SelectList 查询文件管理列表
func (s *sFile) SelectList(ctx context.Context, in *systemModel.FileListInput) (out *systemModel.FileListOutput, err error) {
	out = &systemModel.FileListOutput{}
	m := dao.File.Ctx(ctx).As("f").
		LeftJoin(dao.FileDriver.Table(), "d", fmt.Sprintf("f.%s=d.%s", dao.File.Columns().DriverId, dao.FileDriver.Columns().Id))
	if gstr.Trim(in.Key) != "" {
		m = m.WherePrefixLike("f", dao.File.Columns().Key, "%"+in.Key+"%")
	}
	out.Total, err = m.Count()
	if err != nil || out.Total == 0 {
		return
	}

	err = commonService.BizCtx().Page(ctx, m).
		FieldsPrefix("f", &entity.File{}).
		Fields(fmt.Sprintf("d.%s AS driverName", dao.FileDriver.Columns().Name)).
		Scan(&out.List)
	return
}

// Insert 新增文件管理
func (s *sFile) Insert(ctx context.Context, in *systemModel.FileAddInput) (err error) {
	_, err = dao.File.Ctx(ctx).InsertAndGetId(&do.File{
		DriverId: in.DriverId,
		Key:      in.Key,
		Size:     in.Size,
		Type:     in.Type,
		Name:     in.Name,
		OwnerId:  in.OwnerId,
		UserType: in.UserType,
	})
	return
}

// DeleteByIds 批量删除文件管理
func (s *sFile) DeleteByIds(ctx context.Context, ids []int64) (err error) {
	files := ([]*entity.File)(nil)
	if err = dao.File.Ctx(ctx).WhereIn(dao.File.Columns().Id, ids).Scan(&files); err != nil {
		return err
	}

	if _, err = dao.File.Ctx(ctx).Where(dao.File.Columns().Id, ids).Delete(); err != nil {
		return err
	}

	for _, file := range files {
		driver, err := service.FileDriver().SelectById(ctx, file.DriverId)
		if err != nil {
			continue
		}
		store, err := filesys.NewStore(driver.Driver, driver.Config.Interface())
		if err != nil {
			continue
		}
		err = store.Delete(ctx, file.Key)
	}
	return
}

// GetExtension 根据Content-Type获取文件后缀
func (s *sFile) GetExtension(prefix string) string {
	switch prefix {
	case mime_type.ImagePng:
		return "png"
	case mime_type.ImageJpg:
		return "jpg"
	case mime_type.ImageJpeg:
		return "jpeg"
	case mime_type.ImageBmp:
		return "bmp"
	case mime_type.ImageGif:
		return "gif"
	default:
		return ""
	}
}

// GetFileExt 获取上传文件的后缀
func (s *sFile) GetFileExt(file *ghttp.UploadFile) string {
	ext := gstr.SubStrFromREx(file.Filename, ".")
	if ext != "" {
		return ext
	}
	contentType := file.Header.Get("Content-Type")
	return s.GetExtension(contentType)
}

// CheckAllowDownload 检查文件是否可下载
//	@param resource 需要下载的文件
//	@return true 正常 false 非法
func (s *sFile) CheckAllowDownload(ctx context.Context, resource string) (bool, error) {
	// 禁止目录上跳级别
	if gstr.Contains(resource, "..") {
		return false, nil
	}

	allowedExt, err := service.File().GetUploadAllowedExt(ctx)
	if err != nil {
		return false, gerror.Wrap(err, "系统错误")
	}

	// 检查是否允许下载的文件规则
	return gstr.InArray(allowedExt, gfile.ExtName(resource)), nil
}

// SetAttachmentResponseHeader 设置文件下载响应头
func (s *sFile) SetAttachmentResponseHeader(ctx context.Context, realFileName string) {
	r := g.RequestFromCtx(ctx)
	realFileName = url.QueryEscape(realFileName)
	percentEncodedFileName, err := gregex.ReplaceString("\\+", "%20", realFileName)
	if err != nil {
		g.Log().Error(ctx, err)
		percentEncodedFileName = realFileName
	}
	r.Response.Header().Set("Content-Type", "application/octet-stream; charset=UTF-8")
	r.Response.Header().Set("Access-Control-Expose-Headers", "Content-Disposition,download-filename")
	r.Response.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s\"; filename*=utf-8 %s", percentEncodedFileName, percentEncodedFileName))
	r.Response.Header().Set("download-filename", percentEncodedFileName)
}

// Upload 上传文件
func (s *sFile) Upload(ctx context.Context, in *systemModel.FileUploadInput) (out *systemModel.FileUploadOutput, err error) {
	maxLen, err := service.File().GetUploadMaxFileNameLen(ctx)
	if err != nil {
		return nil, gerror.Wrap(err, "系统错误")
	}
	// 效验文件名长度
	if int64(len(in.File.Filename)) > maxLen {
		err = gerror.Newf("上传文件名不能超过%d字节", maxLen)
		return
	}
	maxSize, err := service.File().GetUploadMaxSize(ctx)
	if err != nil {
		return nil, gerror.Wrap(err, "系统错误")
	}
	// 效验文件大小
	if in.File.Size > maxSize {
		err = gerror.Newf("上传文件不能超过%dMB", maxSize/1024/1024)
		return
	}

	// 效验文件后缀
	ext := s.GetFileExt(in.File)
	if !g.IsEmpty(in.AllowedExtension) && !gstr.InArray(in.AllowedExtension, ext) {
		err = gerror.Newf("文件[" + in.File.Filename + "]后缀[" + ext + "]不正确，请上传" + gstr.Join(in.AllowedExtension, ",") + "格式")
		return
	}

	originalFilename := in.File.Filename
	fileName := fmt.Sprintf("%s.%s", guid.S(), ext)
	tfile, err := in.File.Open()
	if err != nil {
		return nil, err
	}
	defer func() {
		_ = tfile.Close()
	}()
	// 上传文件
	err = filesys.Upload(ctx, fileName, tfile, in.File.Size)
	if err != nil {
		err = gerror.Wrap(err, "上传文件失败")
		return
	}

	// 获取驱动
	driver, err := service.FileDriver().GetMasterDriver(ctx)
	if err != nil {
		_ = filesys.Delete(ctx, fileName)
		return nil, err
	}

	// 获取访问地址
	url, err := filesys.GetSignURL(ctx, fileName)
	if err != nil {
		return nil, err
	}

	// 保存数据
	if err = service.File().Insert(ctx, &systemModel.FileAddInput{
		DriverId: driver.Id,
		Key:      fileName,
		Size:     in.File.Size,
		Type:     ext,
		Name:     originalFilename,
		OwnerId:  in.OwnerId,
		UserType: in.UserType,
	}); err != nil {
		_ = filesys.Delete(ctx, fileName)
		return nil, err
	}

	out = &systemModel.FileUploadOutput{
		Url:      url,
		FileName: fileName,
		Name:     originalFilename,
		//NewFileName: fileName,
	}
	return
}

// GetUploadMaxSize 获取上传文件最大大小
func (s *sFile) GetUploadMaxSize(ctx context.Context) (int64, error) {
	configValue, err := service.Config().GetByConfigKey(ctx, config_consts.SysUploadMaxSize)
	if err != nil {
		return 0, err
	}
	return gconv.Int64(configValue), nil
}

// GetUploadMaxFileNameLen 获取上传文件名最大长度
func (s *sFile) GetUploadMaxFileNameLen(ctx context.Context) (int64, error) {
	configValue, err := service.Config().GetByConfigKey(ctx, config_consts.SysUploadMaxFileNameLen)
	if err != nil {
		return 0, err
	}
	return gconv.Int64(configValue), nil
}

// GetUploadAllowedExt 获取上传文件允许的扩展名
func (s *sFile) GetUploadAllowedExt(ctx context.Context) ([]string, error) {
	configValue, err := service.Config().GetByConfigKey(ctx, config_consts.SysUploadAllowedExt)
	if err != nil {
		return []string{}, err
	}
	return gstr.Split(configValue, ","), nil
}

// GetTempFileDir 获取临时文件存储目录
func (s *sFile) GetTempFileDir(ctx context.Context) (string, error) {
	configValue, err := service.Config().GetByConfigKey(ctx, config_consts.SysTempFileDir)
	if err != nil {
		return "", err
	}
	if configValue == "" {
		return "", gerror.New("请配置临时文件存储目录")
	}
	return configValue, nil
}

// SaveByBytes 保存文件
func (s *sFile) SaveByBytes(ctx context.Context, in *systemModel.FileSaveByBytesInput) (out *systemModel.FileSaveByBytesOutput, err error) {
	size, err := s.GetUploadMaxSize(ctx)
	if err != nil {
		return nil, gerror.Wrap(err, "系统错误")
	}
	// 效验文件大小
	if int64(len(in.FileBytes)) > size {
		err = gerror.Newf("上传文件不能超过%dMB", size/1024/1024)
		return
	}

	// 效验文件后缀
	if !g.IsEmpty(in.AllowedExtension) && !gstr.InArray(in.AllowedExtension, in.Ext) {
		err = gerror.Newf("文件后缀[" + in.Ext + "]不正确，请上传" + gstr.Join(in.AllowedExtension, ",") + "格式")
		return
	}

	fileName := fmt.Sprintf("%s.%s", guid.S(), in.Ext)
	buff := bytes.NewBuffer(in.FileBytes)
	if err = filesys.Upload(ctx, fileName, buff, int64(buff.Len())); err != nil {
		return
	}

	out = &systemModel.FileSaveByBytesOutput{
		FileName: fileName,
	}
	return
}
