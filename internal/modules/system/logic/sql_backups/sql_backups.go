// ============================================================================
// This is auto-generated by gen tool only once. Fill this file as you wish.
// 数据库备份表Logic层
// @author kennylixi
// @date 2023-05-07 13:31:59
// ============================================================================

package sql_backups

import (
	"bytes"
	"context"
	"fmt"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/os/gctx"
	"github.com/gogf/gf/v2/os/gfile"
	"github.com/gogf/gf/v2/os/gproc"
	"github.com/gogf/gf/v2/os/gtime"
	"github.com/gogf/gf/v2/text/gstr"
	"github.com/gogf/gf/v2/util/grand"
	commonService "github.com/kennylixi/gadmin/internal/modules/common/service"
	"github.com/kennylixi/gadmin/internal/modules/system/dao"
	"github.com/kennylixi/gadmin/internal/modules/system/model"
	"github.com/kennylixi/gadmin/internal/modules/system/model/do"
	"github.com/kennylixi/gadmin/internal/modules/system/model/entity"
	sysService "github.com/kennylixi/gadmin/internal/modules/system/service"
	"runtime"
	"strings"
)

// SqlBackups 数据库备份表管理服务
type sSqlBackups struct {
}

const cfgKey = "backup"

var backUpCfg *model.SqlBackupsCfg

func init() {
	ctx := gctx.New()
	backUpCfg = &model.SqlBackupsCfg{
		Path: "./backups",
	}
	if err := g.Cfg().MustGet(ctx, cfgKey).Scan(&backUpCfg); err != nil {
		g.Log().Fatalf(ctx, "初始化数据库备份模块错误: %#v", err)
	}
	if !gfile.Exists(backUpCfg.Path) {
		if err := gfile.Mkdir(backUpCfg.Path); err != nil {
			g.Log().Fatalf(ctx, "初始化数据库备份模块目录错误: %#v", err)
		}
	}
	sysService.RegisterSqlBackups(New())
}

func New() *sSqlBackups {
	return &sSqlBackups{}
}

// SelectById 查询数据库备份表信息
func (s *sSqlBackups) SelectById(ctx context.Context, backupsId int64) (sysSqlBackups *entity.SqlBackups, err error) {
	err = dao.SqlBackups.Ctx(ctx).Fields(entity.SqlBackups{}).Scan(&sysSqlBackups, dao.SqlBackups.Columns().BackupsId, backupsId)
	if err != nil {
		return nil, err
	}
	if sysSqlBackups == nil {
		return nil, gerror.New("数据不存在")
	}

	return sysSqlBackups, nil
}

// SelectList 查询数据库备份表列表
func (s *sSqlBackups) SelectList(ctx context.Context, in *model.SqlBackupsListInput) (out *model.SqlBackupsListOutput, err error) {
	out = &model.SqlBackupsListOutput{}
	m := dao.SqlBackups.Ctx(ctx)
	if in.FileName != "" {
		m = m.WhereLike(dao.SqlBackups.Columns().FileName, "%"+in.FileName+"%")
	}
	out.Total, err = m.Count()
	if err != nil || out.Total == 0 {
		return
	}
	m = commonService.BizCtx().WhereBeginTime(ctx, dao.SqlBackups.Columns().CreatedAt, m)
	m = commonService.BizCtx().WhereEndTime(ctx, dao.SqlBackups.Columns().CreatedAt, m)
	err = commonService.BizCtx().Page(ctx, m).Fields(&model.SqlBackupsListItem{}).Scan(&out.List)
	return
}

// 拼装导出命令
func (s *sSqlBackups) buidDumpCmd(ctx context.Context, zipPwd string) (dumpCmd, dumpFileName, zipFileName string) {
	var dumpArgs []string
	dbCfg := g.DB().GetConfig()

	// 根据系统类型cd到指定目录
	switch runtime.GOOS {
	case "windows":
		realPath := gfile.RealPath(backUpCfg.Path)
		driverName := gstr.SubStr(realPath, 0, gstr.Pos(realPath, ":"))
		dumpArgs = append(dumpArgs, driverName, "&&", "cd", realPath)
	default:
		dumpArgs = append(dumpArgs, "cd", backUpCfg.Path)
	}
	dumpArgs = append(dumpArgs, "&&")

	dumpArgs = append(dumpArgs, "mysqldump")
	dumpArgs = append(dumpArgs, "--host", dbCfg.Host)
	dumpArgs = append(dumpArgs, "--port", dbCfg.Port)
	dumpArgs = append(dumpArgs, "-u", dbCfg.User)
	dumpArgs = append(dumpArgs, `-p`+dbCfg.Pass)
	for _, table := range backUpCfg.ExcludeTables {
		dumpArgs = append(dumpArgs, "--ignore-table="+dbCfg.Name+"."+table)
	}

	if len(backUpCfg.Args) > 0 {
		dumpArgs = append(dumpArgs, backUpCfg.Args)
	}

	dumpArgs = append(dumpArgs, dbCfg.Name)
	if len(backUpCfg.Tables) > 0 {
		dumpArgs = append(dumpArgs, backUpCfg.Tables...)
	}

	sqlFileName := fmt.Sprintf("%s_%s%s", dbCfg.Name, gtime.Now().Format("Ymdhis"), grand.Digits(5))
	dumpFileName = sqlFileName + ".sql"
	zipFileName = sqlFileName + ".zip"
	dumpArgs = append(dumpArgs, ">"+dumpFileName)

	// 压缩命令
	dumpArgs = append(dumpArgs, "&&")
	dumpArgs = append(dumpArgs, "zip")
	if zipPwd != "" {
		dumpArgs = append(dumpArgs, "-P", zipPwd)
	}
	dumpArgs = append(dumpArgs, zipFileName, dumpFileName)

	dumpCmd = strings.Join(dumpArgs, " ")
	return
}

// Backup 新增数据库备份表
func (s *sSqlBackups) Backup(ctx context.Context) (err error) {
	pwd := grand.S(34)
	dumpCmd, dumpFileName, zipFileName := s.buidDumpCmd(ctx, pwd)
	dumpFilePath, zipFilePath := backUpCfg.Path+"/"+dumpFileName, backUpCfg.Path+"/"+zipFileName
	defer func() {
		if dumpFilePath != "" {
			gfile.Remove(dumpFilePath)
		}
		if err != nil {
			if zipFilePath != "" {
				gfile.Remove(zipFilePath)
			}
		}
	}()

	// 导出
	proc := gproc.NewProcessCmd(dumpCmd)
	errBuf := bytes.NewBuffer(nil)
	proc.Stderr = errBuf
	proc.Stdout = nil
	if err = proc.Run(ctx); err != nil {
		g.Log().Errorf(ctx, "备份数据错误: %s: %s", err, errBuf.String())
		err = gerror.Wrap(err, "备份失败")
		return
	}

	_, err = dao.SqlBackups.Ctx(ctx).InsertAndGetId(&do.SqlBackups{
		Password: pwd,
		FileName: gfile.Basename(zipFilePath),
		FileSize: uint64(gfile.Size(zipFilePath)),
	})
	if err != nil {
		g.Log().Errorf(ctx, "备份数据保存数据失败: %#v", err)
		return
	}

	return
}

// Recover 恢复备份
func (s *sSqlBackups) Recover(ctx context.Context, backupsId int64) (err error) {
	backup, err := s.SelectById(ctx, backupsId)
	if err != nil {
		return err
	}
	zipFilePath := backUpCfg.Path + "/" + backup.FileName
	sqlFilePath := gstr.TrimRight(zipFilePath, gfile.Ext(zipFilePath)) + ".sql"
	defer func() {
		gfile.Remove(sqlFilePath)
	}()

	dbCfg := g.DB().GetConfig()
	cmdFormat := "unzip -oP %s %s -d %s && mysql -h%s -P%s -u%s -p%s %s <%s"
	proc := gproc.NewProcessCmd(fmt.Sprintf(cmdFormat, backup.Password, zipFilePath, backUpCfg.Path, dbCfg.Host, dbCfg.Port, dbCfg.User, dbCfg.Pass, dbCfg.Name, sqlFilePath))
	errBuf := bytes.NewBuffer(nil)
	proc.Stderr = errBuf
	proc.Stdout = nil
	if err = proc.Run(gctx.New()); err != nil {
		g.Log().Errorf(gctx.New(), "备份数据错误: %s: %s", err, errBuf.String())
		err = gerror.Wrap(err, "恢复失败")
		return
	}
	return
}

// DeleteByIds 批量删除数据库备份表
func (s *sSqlBackups) DeleteByIds(ctx context.Context, backupsIds []int64) (err error) {
	// 先删除备份文件
	for _, id := range backupsIds {
		backup, _ := s.SelectById(ctx, id)
		if backup != nil {
			gfile.Remove(backUpCfg.Path + "/" + backup.FileName)
		}
	}
	// 删除数据
	_, err = dao.SqlBackups.Ctx(ctx).Where(dao.SqlBackups.Columns().BackupsId, backupsIds).Delete()
	return err
}
