// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package dao

import (
	"context"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/text/gstr"
	commonService "github.com/kennylixi/gadmin/internal/modules/common/service"
	"github.com/kennylixi/gadmin/internal/modules/system/dao/internal"
	"github.com/kennylixi/gadmin/internal/modules/system/model/do"
	"github.com/kennylixi/gadmin/internal/modules/system/model/entity"
)

// internalOperLogDao is internal type for wrapping internal DAO implements.
type internalOperLogDao = *internal.OperLogDao

// operLogDao is the data access object for table sys_oper_log.
// You can define custom methods on it to extend its functionality as you wish.
type operLogDao struct {
	internalOperLogDao
}

var (
	// OperLog is globally public accessible object for table sys_oper_log operations.
	OperLog = operLogDao{
		internal.NewOperLogDao(),
	}
)

// Fill with you ideas below.

// Add 新增操作日志
//	@param operLog 操作日志对象
func (d *operLogDao) Add(ctx context.Context, operLog *do.OperLog) (int64, error) {
	return OperLog.Ctx(ctx).InsertAndGetId(operLog)
}

// SelectList 查询系统操作日志集合
//	@param operLog 操作日志对象
//	@return 操作日志集合
func (d *operLogDao) SelectList(ctx context.Context, openLog *entity.OperLog) (list []*entity.OperLog, total int, err error) {
	m := OperLog.Ctx(ctx)
	if title := gstr.Trim(openLog.Title); len(title) > 0 {
		m = m.WhereLike(OperLog.Columns().Title, "%"+title+"%")
	}
	if operName := gstr.Trim(openLog.OperName); len(operName) > 0 {
		m = m.WhereLike(OperLog.Columns().OperName, "%"+operName+"%")
	}
	if openLog.Status > 0 {
		m = m.Where(OperLog.Columns().Status, openLog.Status)
	}
	if openLog.BusinessType > 0 {
		m = m.Where(OperLog.Columns().BusinessType, openLog.BusinessType)
	}
	m = commonService.BizCtx().WhereBeginTime(ctx, OperLog.Columns().OperTime, m)
	m = commonService.BizCtx().WhereEndTime(ctx, OperLog.Columns().OperTime, m)

	total, err = m.Count()
	if err != nil || total == 0 {
		return
	}

	list = ([]*entity.OperLog)(nil)
	err = commonService.BizCtx().Page(ctx, m).Fields(&entity.OperLog{}).Scan(&list)

	return
}

// DeleteByIds 批量删除系统操作日志
//	@param operIds 需要删除的操作日志ID
//	@return 结果
func (d *operLogDao) DeleteByIds(ctx context.Context, operIds []int64) error {
	_, err := d.Ctx(ctx).Delete(OperLog.Columns().OperId, operIds)
	return err
}

// SelectById 查询操作日志详细
//	@param operId 操作ID
//	@return 操作日志对象
func (d *operLogDao) SelectById(ctx context.Context, operId int64) (operLog *entity.OperLog, err error) {
	err = d.Ctx(ctx).Scan(&operLog, OperLog.Columns().OperId, operId)
	if err != nil {
		return nil, err
	}
	if operLog == nil {
		return nil, gerror.New("数据不存在")
	}
	return operLog, nil
}

// Clean 清空操作日志
func (d *operLogDao) Clean(ctx context.Context) error {
	_, err := g.DB().Exec(ctx, "truncate table "+OperLog.Table())
	if err != nil {
		g.Log().Error(ctx, err)
		err = gerror.New("清除失败")
	}
	return err
}
