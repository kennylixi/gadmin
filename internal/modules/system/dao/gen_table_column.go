// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package dao

import (
	"context"
	"github.com/gogf/gf/v2/database/gdb"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/kennylixi/gadmin/internal/modules/system/dao/internal"
	"github.com/kennylixi/gadmin/internal/modules/system/model/entity"
)

// internalGenTableColumnDao is internal type for wrapping internal DAO implements.
type internalGenTableColumnDao = *internal.GenTableColumnDao

// genTableColumnDao is the data access object for table gen_table_column.
// You can define custom methods on it to extend its functionality as you wish.
type genTableColumnDao struct {
	internalGenTableColumnDao
}

var (
	// GenTableColumn is globally public accessible object for table gen_table_column operations.
	GenTableColumn = genTableColumnDao{
		internal.NewGenTableColumnDao(),
	}
)

// Fill with you ideas below.

// SelectDbTableColumnsByName 根据表名称查询列信息
//	@param tableName 表名称
//	@return 列信息
func (d *genTableColumnDao) SelectDbTableColumnsByName(ctx context.Context, tableName string) (columns []*entity.GenTableColumn, err error) {
	sqlStr := "select column_name, (case when (is_nullable = 'no' && column_key != 'PRI') then '1' else null end) as is_required, (case when column_key = 'PRI' then '1' else '0' end) as is_pk, ordinal_position as sort, column_comment, (case when extra = 'auto_increment' then '1' else '0' end) as is_increment, column_type from information_schema.columns where table_schema = (select database()) and table_name = (?) order by ordinal_position"
	if err = d.DB().GetScan(ctx, &columns, sqlStr, tableName); err != nil {
		err = gerror.Wrap(err, "查询列信息失败")
	}
	return
}

// SelectGenTableColumnListByTableId 查询业务字段列表
//	@param tableId 业务字段编号
//	@return 业务字段集合
func (d *genTableColumnDao) SelectGenTableColumnListByTableId(ctx context.Context, tableId int64) (columns []*entity.GenTableColumn, err error) {
	err = GenTableColumn.Ctx(ctx).Fields(&entity.GenTableColumn{}).
		Where(GenTableColumn.Columns().TableId, tableId).
		Order(GenTableColumn.Columns().Sort).
		Scan(&columns)
	return
}

// InsertGenTableColumn 新增业务字段
//	@param genTableColumn 业务字段信息
//	@return 结果
func (d *genTableColumnDao) InsertGenTableColumn(ctx context.Context, genTableColumn *entity.GenTableColumn, tx ...gdb.TX) (int64, error) {
	m := GenTableColumn.Ctx(ctx)
	if len(tx) > 0 {
		m = m.TX(tx[0])
	}
	count, err := m.InsertAndGetId(genTableColumn)
	if err != nil {
		return 0, gerror.Wrap(err, "新增业务字段失败")
	}
	return count, nil
}

// UpdateGenTableColumn 修改业务字段
//	@param genTableColumn 业务字段信息
//	@return 结果
func (d *genTableColumnDao) UpdateGenTableColumn(ctx context.Context, genTableColumn *entity.GenTableColumn, tx ...gdb.TX) (int64, error) {
	m := GenTableColumn.Ctx(ctx)
	if len(tx) > 0 {
		m = m.TX(tx[0])
	}
	count, err := m.UpdateAndGetAffected(genTableColumn, GenTableColumn.Columns().ColumnId, genTableColumn.ColumnId)
	if err != nil {
		return 0, gerror.Wrap(err, "修改业务字段失败")
	}
	return count, nil
}

// DeleteGenTableColumnsByIds 删除业务字段
//	@param ids 列数据
//	@return 结果
func (d *genTableColumnDao) DeleteGenTableColumnsByIds(ctx context.Context, ids []int64, tx ...gdb.TX) (int64, error) {
	m := GenTableColumn.Ctx(ctx)
	if len(tx) > 0 {
		m = m.TX(tx[0])
	}
	result, err := m.Delete(GenTableColumn.Columns().ColumnId, ids)
	if err != nil {
		return 0, gerror.Wrap(err, "删除业务字段失败")
	}

	count, _ := result.RowsAffected()
	return count, nil
}

// DeleteGenTableColumnByIds 批量删除业务字段
//	@param ids 需要删除的数据ID
//	@return 结果
func (d *genTableColumnDao) DeleteGenTableColumnByIds(ctx context.Context, ids []int64, tx ...gdb.TX) (int64, error) {
	m := GenTableColumn.Ctx(ctx)
	if len(tx) > 0 {
		m = m.TX(tx[0])
	}
	result, err := m.Delete(GenTableColumn.Columns().TableId, ids)
	if err != nil {
		return 0, gerror.Wrap(err, "批量删除业务字段失败")
	}
	count, _ := result.RowsAffected()
	return count, nil
}
